<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>2021-05-13-MySQL 索引总结 - ⋆北北の酱⋆</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="⋆北北の酱⋆"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="⋆北北の酱⋆"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="尚未执佩剑，转眼即江湖"><meta property="og:type" content="blog"><meta property="og:title" content="北北の酱"><meta property="og:url" content="https://blog.lovewinter.top/"><meta property="og:site_name" content="北北の酱"><meta property="og:description" content="尚未执佩剑，转眼即江湖"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><meta property="article:published_time" content="2021-05-13T14:20:20.000Z"><meta property="article:modified_time" content="2022-03-25T06:28:59.859Z"><meta property="article:author" content="ellisonPei"><meta property="article:tag" content="MySQL 索引总结"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://peialan.github.io/2021/05/13/2021-04-30-MySQL%E7%B4%A2%E5%BC%95%E5%A4%8D%E4%B9%A0/"},"headline":"北北の酱","image":["https://peialan.github.io/medias/blog/image-20210430104449280-9751338.png","https://peialan.github.io/medias/blog/image-20210430%E4%BA%8C%E5%8F%89%E6%A0%91.png","https://peialan.github.io/medias/blog/image-20210430AVL.png","https://peialan.github.io/medias/blog/image-20210430(noavl).png","https://peialan.github.io/medias/blog/image-20210510154619377.png","https://peialan.github.io/medias/blog/image-20210510163435857.png","https://peialan.github.io/medias/blog/image-20210510163702328.png","https://peialan.github.io/medias/blog/image-20210510164318050.png","https://peialan.github.io/medias/blog/image-20210510173630220.png","https://peialan.github.io/medias/blog/image-20210512110647519.png","https://peialan.github.io/medias/blog/image-20210512172539977.png"],"datePublished":"2021-05-13T14:20:20.000Z","dateModified":"2022-03-25T06:28:59.859Z","author":{"@type":"Person","name":"EllisonPei"},"description":"尚未执佩剑，转眼即江湖"}</script><link rel="canonical" href="https://peialan.github.io/2021/05/13/2021-04-30-MySQL%E7%B4%A2%E5%BC%95%E5%A4%8D%E4%B9%A0/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><script async="" referrerpolicy="no-referrer" src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="/js/md5.min.js"></script><meta name="generator" content="Hexo 5.4.1"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m4uyne2jj20m606cgm1.jpg" alt="⋆北北の酱⋆" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/self-talking">碎碎念</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeiAlan"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2021-05-13  <a class="commentCountImg" href="/2021/05/13/2021-04-30-MySQL%E7%B4%A2%E5%BC%95%E5%A4%8D%E4%B9%A0/#comment-container"><span class="display-none-class">/2021/05/13/2021-04-30-MySQL索引复习/</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="5dd874d1a09ce8f4f9a7413cdb61be00">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>12.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile">2021-05-13-MySQL 索引总结</h1><div class="content"><h1 id="MySQL-索引总结"><a href="#MySQL-索引总结" class="headerlink" title="MySQL 索引总结"></a>MySQL 索引总结</h1><h2 id="生活中的索引"><a href="#生活中的索引" class="headerlink" title="生活中的索引"></a>生活中的索引</h2><p><code>MySQL</code> 官方对索引的定义为：索引<code>Index</code>是帮助 <code>MySQL</code> 高效获取数据的 数据结构。可以得到索引的本质：索引是数据结构。<br>上面的理解比较抽象，举一个例子，平时看任何一本书，首先看到的都是目 录，通过目录去查询书籍里面的内容会非常的迅速。</p>
<h2 id="MySQL中的索引"><a href="#MySQL中的索引" class="headerlink" title="MySQL中的索引"></a>MySQL中的索引</h2><span id="more"></span>

<p><img src="/medias/blog/image-20210430104449280-9751338.png" alt="image-20210430104449280"></p>
<p><code>InnoDB</code> 存储引擎支持以下几种常见的索引：<strong>B+树索引</strong>、<strong>全文索引</strong>、<strong>哈希索引</strong>，其中比较关键的是 <code>B+</code>树索引，其他的索引有：<strong>聚集索引&#x2F;聚簇索引</strong>、<strong>辅助索引&#x2F;二级索引</strong>、<strong>联合索引&#x2F;复合索引</strong>、<strong>覆盖索引&#x2F;索引覆盖</strong>、<strong>自适应哈希索引</strong>、<strong>全文检索之倒排索引</strong>。 </p>
<p>也有这么分类的：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。</span><br><span class="line"></span><br><span class="line">唯一索引：索引列的值必须唯一，但允许有空值。</span><br><span class="line"></span><br><span class="line">复合索引：即一个索引包含多个列。</span><br><span class="line"></span><br><span class="line">聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决 于不同的实现，InnoDB 的聚簇索引其实就是在同一个结构中保存了 B-Tree 索引(技术上来说 是 B+Tree)和数据行。 </span><br><span class="line"></span><br><span class="line">非聚簇索引：不是聚簇索引，就是非聚簇索引。</span><br></pre></td></tr></table></figure>


<p><strong>HashMap 适合做数据库索引吗？</strong> </p>
<p>1、<code>hash</code> 表只能匹配是否相等，不能实现范围查找； </p>
<p>2、当需要按照索引进行 <code>order by</code> 时，<code>hash</code> 值没办法支持排序； </p>
<p>3、组合索引可以支持部分索引查询，如<code>(a,b,c)</code>的组合索引，查询中只用到了 </p>
<p><code>a</code>和 <code>b </code>也可以查询的，如果使用 <code>hash</code> 表，组合索引会将几个字段合并 <code>hash</code>，没 </p>
<p>办法支持部分索引； </p>
<p>4、当数据量很大时，<code>hash</code> 冲突的概率也会非常大。 </p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><code>B+</code>树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最常用 和最为有效的索引。<code>B+</code>树索引的构造类似于二叉树，根据键值（Key Value）快速 找到数据。注意 <code>B+</code>树中的 <code>B</code> 不是代表二叉(binary)，而是代表平衡(balance)，因 为 <code>B+</code>树是从最早的平衡二叉树演化而来，但是 <code>B+</code>树不是一个二叉树。<br>在了解 <code>B+</code>树索引之前先要知道与之密切相关的一些算法与数据结构，这有 助于更好的理解 <code>B+</code>树索引的工作方式，因为 <code>B+</code>树是通过二叉查找树，再由 平衡二叉树，<code>B</code> 树演化而来。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><strong>二分查找法（binary search）</strong> 也称为<strong>折半查找法</strong>，用来查找一组有序的记录数组中的某一记录。<br>其基本思想是：将记录按有序化（递增或递减）排列，在查找过程中采用跳跃式方式查找， 即先以有序数列的中点位置作为比较对象，如果要找的元素值小于该中点元素，则将待查序 列缩小为左半部分，否则为右半部分。通过一次比较，将查找区间缩小一半。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">给出一个例子，注意该例子已经是升序排序的，且查找 数字 48 </span><br><span class="line">数据：5， 10， 19， 21， 31， 37， 42， 48， 50， 52 </span><br><span class="line">下标：0， 1， 2， 3， 4， 5， 6， 7， 8， 9 </span><br><span class="line">• 步骤一：设 low 为下标最小值 0 ， high 为下标最大值 9 ;</span><br><span class="line">• 步骤二：通过 low 和 high 得到 mid ，mid=（low + high） / 2，初始时 mid 为下标 4 (也 可以=5，看具体算法实现)；</span><br><span class="line">• 步骤三 ： mid=4 对应的数据值是 31，31 &lt; 48（要找的数字）；</span><br><span class="line">• 步骤四：通过二分查找的思路，将 low 设置为 31 对应的下标 4 ， high 保持不变为 9 ， 此时 mid 为 6 ；</span><br><span class="line">• 步骤五 ： mid=6 对应的数据值是 42，42 &lt; 48（要找的数字）；</span><br><span class="line">• 步骤六：通过二分查找的思路，将 low 设置为 42 对应的下标 6 ， high 保持不变为 9 ， 此时 mid 为 7 ；</span><br><span class="line">• 步骤七 ： mid=7 对应的数据值是 48，48 == 48（要找的数字），查找结束； 通过 3 次 二分查找 就找到了所要的数字，而顺序查找需 8</span><br></pre></td></tr></table></figure>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>每个节点至多只有二棵子树； </p>
<ul>
<li>二叉树的子树有左右之分，次序不能颠倒； </li>
<li>一棵深度为 k，且有 个节点，称为满二叉树(<code>Full Tree</code>)； </li>
<li>一棵深度为 k，且 root 到 k-1 层的节点树都达到最大，第 k 层的所有节点都 连续集中 在 最左边,此时为完全二叉树（<code>Complete Tree</code>）</li>
</ul>
<p><img src="/medias/blog/image-20210430%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20210430143943895"></p>
<h4 id="平衡二叉树（AVL-树）"><a href="#平衡二叉树（AVL-树）" class="headerlink" title="平衡二叉树（AVL-树）"></a>平衡二叉树（AVL-树）</h4><ul>
<li>左子树和右子树都是平衡二叉树； </li>
<li>左子树和右子树的高度差绝对值不超过 1；</li>
</ul>
<p>平衡二叉树：<br><img src="/medias/blog/image-20210430AVL.png" alt="image-20210430144033003"  /></p>
<p>非平衡二叉树：<br><img src="/medias/blog/image-20210430(noavl).png" alt="image-20210430144144824"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">平衡二叉树的遍历</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前序 ：6 ,3, 2, 5,7, 8（ROOT 节点在开头, 中 -左-右 顺序）</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">中序 ：2, 3, 5, 6,7, 8（中序遍历即为升序，左- 中 -右 顺序）</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后序 ：2, 5, 3, 8,7, 6 （ROOT 节点在结尾，左-右- 中 顺序）</span></span><br></pre></td></tr></table></figure>
<p>平衡二叉树的旋转比较复杂，提供个博客专门详解：<br><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/9609779212/">平衡二叉树【旋转的超详细图解】</a></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>​        B+树是 B 树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵 m 阶的 B+树定义如下: </p>
<ul>
<li><p>每个节点最多可以有 m 个元素； </p>
</li>
<li><p>除了根节点外，每个节点最少有 (m&#x2F;2) 个元素； </p>
</li>
<li><p>如果根节点不是叶节点，那么它最少有 2 个孩子节点； </p>
</li>
<li><p>所有的叶子节点都在同一层； </p>
</li>
<li><p>一个有 k 个孩子节点的非叶子节点有 (k-1) 个元素，按升序排列； </p>
</li>
<li><p>某个元素的左子树中的元素都比它小，右子树的元素都大于或等于它； </p>
</li>
<li><p>非叶子节点只存放关键字和指向下一个孩子节点的索引，记录只存放在叶子节点中； </p>
</li>
<li><p>相邻的叶子节点之间用指针相连。</p>
</li>
</ul>
<p><code>B+</code>树的变体为<code> B*</code>树，在 <code>B+</code>树的非根和非叶子结点再增加指向兄弟的指针；<br><code>B*</code>树定义了非叶子结点关键字个数至少为<code>(2/3)*M</code>，即块的最低使用率为 <code>2/3</code>（代替 <code>B+</code>树的 <code>1/2</code>）。<br> 概要的了解下 <code>B</code> 树和 <code>B+</code>树。 </p>
<p><code>B+</code>树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在 <code>B+</code>树中， 所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点 指针进行连接。比如：</p>
<p><img src="/medias/blog/image-20210510154619377.png" alt="image-20210510154619377"></p>
<h2 id="InnoDB中的索引"><a href="#InnoDB中的索引" class="headerlink" title="InnoDB中的索引"></a>InnoDB中的索引</h2><h3 id="聚集索引-x2F-聚簇索引"><a href="#聚集索引-x2F-聚簇索引" class="headerlink" title="聚集索引&#x2F;聚簇索引"></a>聚集索引&#x2F;聚簇索引</h3><p>​      <code>InnoDB</code> 中使用了聚集索引，就是将表的主键用来构造一棵 B+树，并且将整 张表的行记录数据存放在该 B+树的叶子节点中。也就是所谓的索引即数据，数 据即索引。由于聚集索引是利用表的主键构建的，所以每张表只能拥有一个聚集 索引。</p>
<p>​      聚集索引的叶子节点就是数据页。换句话说，数据页上存放的是完整的每行 记录。因此聚集索引的一个优点就是：通过过聚集索引能获取完整的整行数据。 另一个优点是：对于主键的排序查找和范围查找速度非常快。 </p>
<p>​      如果没有定义主键呢？<code>MySQL</code> 会使用唯一性索引，没有唯一性索引，<code> MySQL</code> 也会创建一个隐含列 <code>RowID </code>来做主键，然后用这个主键来建立聚集索引。</p>
<p><img src="/medias/blog/image-20210510163435857.png" alt="image-20210510163435857"></p>
<h3 id="辅助索引-x2F-二级索引"><a href="#辅助索引-x2F-二级索引" class="headerlink" title="辅助索引&#x2F;二级索引"></a>辅助索引&#x2F;二级索引</h3><p>​      上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为 B+树 中的数据都是按照主键进行排序的,那如果想以别的列作为搜索条件怎么 办？一般会建立多个索引，这些索引被称为辅助索引&#x2F;二级索引。 </p>
<p>​      对于辅助索引(<code>Secondary Index</code>，也称二级索引、非聚集索引)，叶子节点 并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索 引行中还包含了一个书签( bookmark)。该书签用来告诉 InnoDB 存储引擎哪里可 以找到与索引相对应的行数据。因此 InnoDB 存储引擎的辅助索引的书签就是相 应行数据的聚集索引键。</p>
<p><img src="/medias/blog/image-20210510163702328.png" alt="image-20210510163702328"><br>比如辅助索引<code> index(node)</code>，那么叶子节点中包含的数据就包括了(主键、 <code>note</code>)。</p>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>​      辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，<code>InnoDB</code> 存储引擎会遍历辅助索引 并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引） 来找到一个完整的行记录。这个过程也被称为回表。也就是根据辅助索引的值查询一条完整的用户记录需要使用到 <code>2 </code>棵 <code>B+</code>树，即一次辅助索引，一次聚集索引。</p>
<p><img src="/medias/blog/image-20210510164318050.png" alt="image-20210510164318050"><br>​      为什么还需要一次回表操作呢?直接把完整的用户记录放到辅助索引 <code>d</code> 的叶子节点不就好了么？如果把完整的用户记录放到叶子节点是可以不用回表， 但是太占地方了，相当于每建立一棵 <code>B+</code>树都需要把所有的用户记录再都拷贝一 遍，这就有点太浪费存储空间了。而且每次对数据的变化要在所有包含数据的索 引中全部都修改一次，性能也非常低下。<br>​      很明显，回表的记录越少，性能提升就越高，需要回表的记录越多，使用二 级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用二级索引。<br>​      那什么时候采用全表扫描的方式，什么时候使用采用二级索引 + 回表的方 式去执行查询呢？这个就是查询优化器做的工作，查询优化器会事先对表中的记 录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要 回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于 使用二级索引 + 回表的方式。</p>
<h3 id="联合索引-x2F-复合索引"><a href="#联合索引-x2F-复合索引" class="headerlink" title="联合索引&#x2F;复合索引"></a>联合索引&#x2F;复合索引</h3><p>​      前面对索引的描述，隐含了一个条件，那就是构建索引的字段只有一个， 但实践工作中构建索引的完全可以是多个字段。所以，将表上的多个列组合起来 进行索引称之为联合索引或者复合索引，比如 <code>index(a,b)</code>就是将 <code>a</code>,<code>b</code> 两个 列组合起来构成一个索引。<br>​      千万要注意一点，建立联合索引只会建立 1 棵 B+树，多个列分别建立索引 会分别以每个列则建立 <code>B+</code>树，有几个列就有几个 B+树，比如，<code>index(note)</code>、 <code>index(b)</code>，就分别对 <code>note</code>,<code>b</code> 两个列各构建了一个索引。<br>​      index(note,b)在索引构建上，包含了两个意思：<br>​      1、先把各个记录按照 note 列进行排序。<br>​      2、在记录的 note 列相同的情况下，采用 b 列进行排序。</p>
<p><img src="/medias/blog/image-20210510173630220.png" alt="image-20210510173630220"></p>
<h3 id="覆盖索引-x2F-索引覆盖"><a href="#覆盖索引-x2F-索引覆盖" class="headerlink" title="覆盖索引&#x2F;索引覆盖"></a>覆盖索引&#x2F;索引覆盖</h3><p>​      既然多个列可以组合起来构建为联合索引，那么辅助索引自然也可以由多个 列组成。<br>​      <code>InnoDB</code> 存储引擎支持覆盖索引(<code>covering index</code>，或称索引覆盖)，即从辅 助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索 引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索 引，因此可以减少大量的 <code>IO</code>操作。所以记住，覆盖索引并不是索引类型的一种。<br><img src="/medias/blog/image-20210512110647519.png" alt="image-20210512110647519"></p>
<h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>​      <code>InnoDB</code> 存储引擎除了前面所说的各种索引，还有一种自适应哈希索引， 知道 <code>B+</code>树的查找次数,取决于 <code>B+</code>树的高度,在生产环境中,<code>B+</code>树的高度一般为 <code>3~4</code>层,故需要 <code>3~4</code> 次的 <code>IO</code> 查询。<br>​      所以在 <code>InnoDB</code> 存储引擎内部自己去监控索引表，如果监控到某个索引经常 用，那么就认为是热数据，然后内部自己创建一个 <code>hash</code> 索引，称之为自适应哈 希索引( <code>Adaptive Hash Index,AHI</code>)，创建以后，如果下次又查询到这个索引， 那么直接通过 hash 算法推导出记录的地址，直接一次就能查到数据，比重复去 <code>B+ Tree</code> 索引中查询三四次节点的效率高了不少。<br>​      <code>InnoDB</code> 存储引擎使用的哈希函数采用除法散列方式，其冲突机制采用链表 方式。注意，对于自适应哈希索引仅是数据库自身创建并使用的，并不能对 其进行干预。通过命令 <code>show engine innodb status</code> 可以看到当前自适应哈希 索引的使用状况，测试查询结果如下:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">=====================================</span><br><span class="line">2021-05-12 03:11:44 0x7f54701ff700 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 28 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 114812 srv_active, 0 srv_shutdown, 4528160 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 0</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 109540</span><br><span class="line">OS WAIT ARRAY INFO: signal count 109523</span><br><span class="line">RW-shared spins 12, rounds 12, OS waits 0</span><br><span class="line">RW-excl spins 3561, rounds 105825, OS waits 3254</span><br><span class="line">RW-sx spins 6, rounds 129, OS waits 3</span><br><span class="line">Spin rounds per wait: 1.00 RW-shared, 29.72 RW-excl, 21.50 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 2357106</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 2357104 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 7</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421475798915688, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421475798914816, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: waiting for completed aio requests (insert buffer thread)</span><br><span class="line">I/O thread 1 state: waiting for completed aio requests (log thread)</span><br><span class="line">I/O thread 2 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 3 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 4 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 5 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 6 state: waiting for completed aio requests (write thread)</span><br><span class="line">I/O thread 7 state: waiting for completed aio requests (write thread)</span><br><span class="line">I/O thread 8 state: waiting for completed aio requests (write thread)</span><br><span class="line">I/O thread 9 state: waiting for completed aio requests (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i/o&#x27;s:, sync i/o&#x27;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 5</span><br><span class="line">1630 OS file reads, 4387964 OS file writes, 3908576 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 2 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 3 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 2 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 3 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 3 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 3 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 3 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 12 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number          856480558</span><br><span class="line">Log buffer assigned up to    856480558</span><br><span class="line">Log buffer completed up to   856480558</span><br><span class="line">Log written up to            856480558</span><br><span class="line">Log flushed up to            856480558</span><br><span class="line">Added dirty pages up to      856480558</span><br><span class="line">Pages flushed up to          856480558</span><br><span class="line">Last checkpoint at           856480558</span><br><span class="line">1270972 log i/o&#x27;s done, 0.00 log i/o&#x27;s/second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137363456</span><br><span class="line">Dictionary memory allocated 1032309</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       5564</span><br><span class="line">Database pages     2597</span><br><span class="line">Old database pages 938</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 2, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 1533, created 1064, written 1424848</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 2597, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID=1, Main thread ID=140000311064320 , state=sleeping</span><br><span class="line">Number of rows inserted 43526, updated 116136, deleted 549, read 30264535</span><br><span class="line">0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br></pre></td></tr></table></figure>
<p>​      哈希索引只能用来搜索等值的查询,如 <code>SELECT* FROM table WHERE index co=xxx</code>。而对于其他查找类型,如范围查找,是不能使用哈希索引的, 因此这里出现了 <code>non- hash searches/s </code>的情况。通过 <code>hash searches: non- hash searches</code> 可以大概了解使用哈希索引后的效率。<br>​      由于 <code>AHI</code> 是由 <code>InnoDB</code> 存储引擎控制的,因此这里的信息只供参考。不 过可以通过观察 <code>SHOW ENGINE INNODB STATUS </code>的结果及参数<code>innodb_adaptive_hash_index</code> 来考虑是禁用或启动此特性,默认 AHI 为开启状态。<br>​      什么时候需要禁用呢？如果发现监视索引查找和维护哈希索引结构的额外 开销远远超过了自适应哈希索引带来的性能提升就需要关闭这个功能。<br>​      同时在 <code>MySQL 5.7</code> 中，自适应哈希索引搜索系统被分区。每个索引都绑定到 一个特定的分区，每个分区都由一个单独的 <code>latch</code> 锁保护。分区由<code> innodb_adaptive_hash_index_parts</code> 配置选项控制 。在早期版本中，自适应哈 希索引搜索系统受到单个 <code>latch</code>锁的保护，这可能成为繁重工作负载下的争用 点。<code>innodb_adaptive_hash_index_parts</code> 默认情况下，该 选项设置为 <code>8</code>。最大 设置为 <code>512</code>。当然禁用或启动此特性和调整分区个数这个应该是 DBA 的工作，作为开发了解即可。</p>
<h3 id="全文检索之倒排索引"><a href="#全文检索之倒排索引" class="headerlink" title="全文检索之倒排索引"></a>全文检索之倒排索引</h3><p>​      什么是全文检索（<code>Full-Text Search</code>）？<br>​      它是将存储于数据库中的整本书或整 篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中有关章、 节、段、句、词等信息，也可以进行各种统计和分析。圈子中比较熟知的 <code>Elasticsearch</code>、 <code>Solr</code> 等就是全文检索引擎，底层都是基于<code> Apache Lucene</code> 的。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>朝代(dynasty)</th>
<th>作者(author)</th>
<th>诗词年代(poetry_age)</th>
<th>标题(title)</th>
<th>诗词全文(contents)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>唐</td>
<td>李白</td>
<td></td>
<td>静夜思</td>
<td>床前明月光，疑是地上霜。 <br />举头望明月，低头思故乡。</td>
</tr>
<tr>
<td>2</td>
<td>宋</td>
<td>李清照</td>
<td></td>
<td>如梦令</td>
<td>常记溪亭日暮，沉醉不知归路，兴尽晚回舟，误入藕花深处。争渡，争渡，惊起一滩鸥鹭。</td>
</tr>
<tr>
<td>···</td>
<td>···</td>
<td>···</td>
<td>···</td>
<td>···</td>
<td>···</td>
</tr>
</tbody></table>
<p>​      要根据朝代或者作者寻找诗，都很简单，比如<code>select 诗词全文 from 诗词表 where 作者=‘李白’</code>，如果数据很多，查询速度很慢，怎么办？可以在对应的查询字段上建立索引加速查询。<br>​      但是如果现在有个需求：要求找到包含<strong>“望”</strong>字的诗词怎么办？<br>​      用 <code>select 诗词全文 from 诗词表 where 诗词全文 like‘%望%’</code>，这个意味着 要扫描库中的诗词全文字段，逐条比对，找出所有包含关键词“望”字的记录。<br>​      基本上，数据库中一般的 <code>SQL</code>优化手段都是用不上的。数量少，大概性能还能接 受，如果数据量稍微大点，就完全无法接受了，更何况在互联网这种海量数据的 情况下呢？怎么解决这个问题呢，用<strong>倒排索引</strong>。<br>​      比如现在有： </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">蜀道难（唐）李白 蜀道之难难于上青天，侧身西望长咨嗟。</span><br><span class="line">静夜思（唐）李白 举头望明月，低头思故乡。 </span><br><span class="line">春台望（唐）李隆基 暇景属三春，高台聊四望。 </span><br><span class="line">鹤冲天(宋)柳永 黄金榜上，偶失龙头望。明代暂遗贤，如何向？未遂风云便， 争不恣狂荡。何须论得丧？才子词人，自是白衣卿相。烟花巷陌，依约丹青屏障。 幸有意中人，堪寻访。且恁偎红翠，风流事，平生畅。青春都一饷。忍把浮名， 换了浅斟低唱！ </span><br></pre></td></tr></table></figure>
<p>​      都有望字，于是可以这么保存:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>关键字</th>
<th>蜀道难</th>
<th>静夜思</th>
<th>春台望</th>
<th>鹤冲天</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>望</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>上</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>​      其实，上述诗词的中每个字都可以作为关键字，然后建立关键字和文档之间 的对应关系，也就是标识关键字被哪些文档包含。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​      所以，倒排索引就是，将文档中包含的关键字全部提取处理，然后再将关键字和文档之间的对应关系保存起来，最后再对关键字本身做索引排序。用户在检索某一个关键字是，先对关键字的索引进行查找，再通过关键字与文档的对应关系找到所在文档。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​      在存储在关系型数据库中的数据，需要事先分析将数据拆分为不同的字段，而在 <code>es</code>这类的存储中，需要应用程序根据规则自动提取关键字，并形成对应关系。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="索引在查询中的使用"><a href="#索引在查询中的使用" class="headerlink" title="索引在查询中的使用"></a>索引在查询中的使用</h2><p>​      索引在查询中的作用到底是什么？在的查询中发挥着什么样的作用 呢？<br>​      请记住：<br>​      **1、一个索引就是一个 B+树，索引让的查询可以快速定位和扫描到 需要的数据记录上，加快查询的速度。 **<br>​      <strong>2、一个 select 查询语句在执行过程中一般最多能使用一个二级索引，即 使在 where 条件中用了多个二级索引。</strong></p>
<h3 id="扫描区间"><a href="#扫描区间" class="headerlink" title="扫描区间"></a>扫描区间</h3><p>​      对于某个查询来说，最简单粗暴的执行方案就是扫描表中的所有记录，判断每一条记录是否符合搜索条件。如果符合，就将其发送到客户端，否则就跳过该 记录。这就是全表扫描。<br>​      对于使用<code> InnoDB</code> 存储引擎的表来说，全表扫描意味着从聚簇索引第一个叶 子节点的第一条记录开始，沿着记录所在的单向链表向后扫描，直到最后一个叶 子节点的最后一条记录。虽然全表扫描是一种很笨的执行方案，但却是一种万能 的执行方案，所有的查询都可以使用这种方案来执行，只是效率不高。<br>​      有了索引，利用<code>B+</code>树查找索引列值等于某个值的记录，这样可以明显减少需要扫描的记录数量。由于<code>B+</code>树叶子节点中的记录是按照索引列值由小到 大的顺序排序的，所以即使只扫描某个区间或者某些区间中的记录也可以明显减 少需要扫描的记录数量。<br>比如下面这个查询语句: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> <span class="number">3</span> <span class="keyword">AND</span> id<span class="operator">&lt;=</span> <span class="number">99</span>;</span><br></pre></td></tr></table></figure>
<p>​      这个语句其实是想查找<code>id</code>值在<code>[3,99]</code>区间中的所有聚簇索引记录。可以 通过聚簇索引对应的 <code>B+</code>树快速地定位到 <code>id</code> 值为 <code>3</code> 的那条聚簇索引记录，然后沿着记录所在的单向链表向后扫描,直到某条聚簇索引记录的 <code>id</code> 值不在<code>[3,99]</code>区间 中为止。<br>​      与全表扫描相比，扫描 <code>id</code> 值在<code>[3,99]</code>区间中的记录已经很大程度地减少了需 要扫描的记录数量，所以提升了查询效率。其实所谓的全表扫描，可以理解 为扫描的区间是<code>[负无穷，正无穷]</code>或者<code>[第一条记录，最后一条记录]</code>。</p>
<h3 id="范围区间扫描"><a href="#范围区间扫描" class="headerlink" title="范围区间扫描"></a>范围区间扫描</h3><p>​      其实对于 <code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、 <code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code> LIKE</code> 操作符连接起来，就可以产生一个区间。<br>​      1、<code>IN</code> 操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样 的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="keyword">IN</span> (<span class="number">2021</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">42</span>, yyyy); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time<span class="operator">=</span> <span class="number">2021</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">42</span> <span class="keyword">OR</span> insert_time <span class="operator">=</span> yyyy; </span><br></pre></td></tr></table></figure>
<p>​      2、<code>!=</code>产生的扫描区间呢？<br>比如 <code>SELECT * FROM order_exp WHERE order_no != &#39;DD00_9S&#39; </code>此时使用 <code>idx_expire_time</code> 执行查询时对应的扫描区间就是<code>[第一条记录 , &#39;DD00_9S&#39;]</code>和<code>[ &#39;DD00_9S&#39;,最后一条记录]</code>。<br>​      3、<code>LIKE</code> 操作符比较特殊，只有在匹配完整的字符串或者匹配字符串前缀时 才产生合适的扫描区间。</p>
<h3 id="所有搜索条件都可以使用某个索引的情况"><a href="#所有搜索条件都可以使用某个索引的情况" class="headerlink" title="所有搜索条件都可以使用某个索引的情况"></a>所有搜索条件都可以使用某个索引的情况</h3><p>​      有时候每个搜索条件都可以使用到某个索引，比如下边这个查询语句： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>​      这个查询中的搜索条件都可以使用到<code> idx_order_no</code>，也就是说每个搜索条件 都对应着一个 <code>idx_order_no</code> 的范围区间。这两个小的搜索条件使用 <code>AND </code>连接起 来，也就是要取两个范围区间的交集，两者交集当然就是<code> order_no &gt; &#39;DD00_9S&#39;</code> 了，也就是说上边这个查询使用 <code>idx_order_no </code>的范围区间就是<code>(&#39;DD00_9S&#39;, 最后 一条记录)</code>。<br>​      再看一下使用 <code>OR </code>将多个搜索条件连接在一起的情况： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">OR</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>; </span><br></pre></td></tr></table></figure>
<p>​      <code>OR</code> 意味着需要取各个范围区间的并集，所以上边这个查询使用 <code>idx_expire_time</code> 的范围区间就是<code>( &#39;DD00_6S&#39; ,最后一条记录)</code>。</p>
<h3 id="有的搜索条件无法使用索引的情况"><a href="#有的搜索条件无法使用索引的情况" class="headerlink" title="有的搜索条件无法使用索引的情况"></a>有的搜索条件无法使用索引的情况</h3><p>比如下边这个查询：<br><code>SELECT * FROM order_exp WHERE expire_time&gt; &#39;2021-03-22 18:35:09&#39; AND order_note = &#39;abc&#39;; </code><br>请注意，这个查询语句中能利用的索引只有 <code>idx_expire_time</code> 一个，而 <code>idx_expire_time</code> 这个二级索引的记录中又不包含 <code>order_note</code> 这个字段，所以在使 用二级索引<code>idx_expire_time</code>定位记录的阶段用不到<code> order_note = &#39;abc&#39;</code>这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而范围区间是为了到索引 中取记录中提出的概念，所以在确定范围区间的时候不需要考虑<code> order_note = &#39;abc&#39;</code>这个条件。</p>
<h3 id="使用联合索引执行查询时对应的扫描区间"><a href="#使用联合索引执行查询时对应的扫描区间" class="headerlink" title="使用联合索引执行查询时对应的扫描区间"></a>使用联合索引执行查询时对应的扫描区间</h3><p>​      联合索引的索引列包含多个列，B+树每一层页面以及每个页面中的记录采用 的排序规则较为复杂，以 order_exp 表的 u_idx_day_status 联合索引为例，它采 用的排序规则如下所示：<br>​      先按照 insert_time 列的值进行排序。<br>​      在 insert_time 列的值相同的情况下，再按照 order_status 列的值进行排序。<br>​      在 insert_time 和 order_status 列的值都相同的情况下，再按照 expire_time 列的值进行排序。</p>
<h2 id="创建和删除索引的语句"><a href="#创建和删除索引的语句" class="headerlink" title="创建和删除索引的语句"></a>创建和删除索引的语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看索引 </span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="comment">-- 创建索引 </span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> ] INDEX indexName <span class="keyword">ON</span> mytable(columnname(length)); </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> ] INDEX [indexName] <span class="keyword">ON</span> (columnname(length));</span><br><span class="line"><span class="comment">-- 删除索引 </span></span><br><span class="line"><span class="keyword">DROP</span> INDEX [indexName] <span class="keyword">ON</span> mytable;</span><br></pre></td></tr></table></figure>
<h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><h3 id="空间上的代价"><a href="#空间上的代价" class="headerlink" title="空间上的代价"></a>空间上的代价</h3><p>​      这个是显而易见的，每建立一个索引都要为它建立一棵 <code>B+</code>树，每一棵 <code>B+</code>树 的每一个节点都是一个数据页，一个页默认会占用 <code>16KB </code>的存储空间，一棵很大 的 <code>B+</code>树由许多数据页组成会占据很多的存储空间。</p>
<h3 id="时间上的代价"><a href="#时间上的代价" class="headerlink" title="时间上的代价"></a>时间上的代价</h3><p>​      每次对表中的数据进行增、删、改操作时，都需要去修改各个 <code>B+</code>树索引。 而且<code>B+</code>树每层节点都是按照索引列的值从小到大的顺序排序而组成了 双向链表。不论是叶子节点中的记录，还是非叶子内节点中的记录都是按照索引 列的值从小到大的顺序而形成了一个单向链表。<br>​      而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要 额外的时间进行一些记录移位，页面分裂、页面回收的操作来维护好节点和记录 的排序。如果建了许多索引，每个索引对应的 <code>B+</code>树都要进行相关的维护操 作，这必然会对性能造成影响。</p>
<h2 id="高性能索引创建策略"><a href="#高性能索引创建策略" class="headerlink" title="高性能索引创建策略"></a>高性能索引创建策略</h2><h3 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h3><p>​      在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 <code>TTNYINT</code>、<code>NEDUMNT</code>、<code>INT</code>、<code>BIGTNT</code> 这么几种，它们占用的存储空间依次递增， 这里所说的类型大小指的就是该类型表示的数据范围的大小。能表示的整数 范围当然也是依次递增，如果想要对某个整数列建立索引的话，在表示的整 数范围允许的情况下，尽量让索引列使用较小的类型，比如能使用 <code>INT </code>就不 要使用 <code>BIGINT</code>，能使用 <code>NEDIUMINT</code> 就不要使用<code>INT</code>，这是因为: </p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快（<code>CPU</code> 层次) </li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下 更多的记录，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据 页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>​      这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值， 其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的 数据类型，也就意味着节省更多的存储空间和更高效的 <code>I/O</code>。</p>
<h3 id="索引选择性和前缀索引"><a href="#索引选择性和前缀索引" class="headerlink" title="索引选择性和前缀索引"></a>索引选择性和前缀索引</h3><p>​      创建索引应该选择选择性&#x2F;离散性高的列。索引的选择性&#x2F;离散性是指，不重复的索引值（也称为基数，<code>cardinality</code>)和数据表的记录总数（<code>N</code>)的比值，范围从 <code>1/N</code> 到 <code>1</code> 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 <code>MySQL</code> 在查找时过滤掉更多的行。唯一索引的选择性是 <code>1</code>，这是最好的索引选择性，性能也是最好的。<br>​      很差的索引选择性就是列中的数据重复度很高，比如性别字段，不考虑政治正确的情况下，只有两者可能，男或女。那么在查询时，即使使用这个索引， 从概率的角度来说，依然可能查出一半的数据出来。<br>​      哪列做为索引字段最好？当然是姓名字段，因为里面的数据没有任何重复， 性别字段是最不适合做索引的，因为数据的重复度非常高。<br>​      怎么算索引的选择性&#x2F;离散性？比如 <code>order_exp</code>这个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> order_no)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) cnt <span class="keyword">from</span> order_exp;</span><br></pre></td></tr></table></figure>

<img src="/medias/blog/image-20210512172539977.png" alt="image-20210512172539977" style="zoom: 50%;" />

<p>​      有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提 到过的模拟哈希索引。<br>​      模拟哈希索引：<br>​      <code>order_exp</code> 表中 <code>order_note</code> 字段很长，想把它作为一个索引，可以增加 一个 order_not_hash 字段来存储 <code>order_note</code> 的哈希值，然后在 <code>order_not_hash</code> 上 建立索引，相对于之前的索引速度会有明显提升，一个是对完整的 <code>order_note</code> 做索引，而后者则是用整数哈希值做索引，显然数字的比较比字符串的匹配要高 效得多。<br>​      但是缺陷也很明显：<br>​      1、需要额外维护 <code>order_not_hash </code>字段；<br>​      2、哈希算法的选择决定了哈希冲突的概率，不良的哈希算法会导致重复值 很多；<br>​      3、不支持范围查找。<br>​      还可以做些什么改进呢？还可以索引开始的部分字符，这样可以大大节约索 引空间，从而提高索引效率。但这样也会降低索引的选择性。一般情况下需 要保证某个列前缀的选择性也是足够高的，以满足查询性能。（尤其对于 <code>BLOB</code>、 <code>TEXT</code> 或者很长的 <code>VARCHAR</code> 类型的列，应该使用前缀索引，因为 <code>MySQL</code> 不允许索 引这些列的完整长度）。<br>​      <strong>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便 节约空间)。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换 句话说，前缀的“基数”应该接近于完整列的“基数”</strong>。<br>​      为了决定前缀的合适长度，可以找到最常见的值的列表，然后和最常见的前 缀列表进行比较。</p>
<h3 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a>只为用于搜索、排序或分组的列创建索引</h3><p>​      只为出现在 <code>WHERE</code> 子句中的列、连接子句中的连接列创建索引， 而出现在查询列表中的列一般就没必要建立索引了，除非是需要使用覆盖索引； 又或者为出现在 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句中的列创建索引</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>​      一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。<br>​      遇到的最容易引起困惑的问题就是索引列的顺序。正确的顺序依赖于使 用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。在一个多列 <code>B-Tree</code> 索引中，索引列的顺序意味着索引首先按照最左列进 行排序，其次是第二列，等等。所以，<strong>索引可以按照升序或者降序进行扫描</strong>，以满足精确符合列顺序的 <code>ORDER BY</code>、<code>GROUP BY</code> 和<code> DISTINCT</code> 等子句的查询需求。<br>​      所以多列索引的列顺序至关重要。对于如何选择索引的列顺序有一个经验法则：<strong>将选择性最高的列放到索引最前列。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化 <code>WHERE</code> 条件 的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在 <code>WHERE </code>子句中只使用了索引部分前缀列的查询来说选择性也更高</strong>。<br>​      然而，性能不只是依赖于索引列的选择性，也和查询条件的有关。可能需要 根据那些运行频率最高的查询来调整索引列的顺序，比如排序和分组，让这种情 况下索引的选择性最高。<br>​      同时，在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足 不同类型的查询需求。</p>
<h3 id="设计三星索引"><a href="#设计三星索引" class="headerlink" title="设计三星索引"></a>设计三星索引</h3><h4 id="啥是三星索引？"><a href="#啥是三星索引？" class="headerlink" title="啥是三星索引？"></a>啥是三星索引？</h4><p>​      对于一个查询而言，一个三星索引，可能是其最好的索引。<br>​      如果查询使用三星索引，一次查询通常只需要进行一次磁盘随机读以及一次窄索引片的扫描，因此其相应时间通常比使用一个普通索引的响应时间少几个数量级。<br>​      三星索引概念是在<code>《Rrelational Database Index Design and the optimizers》</code> 一 书中提出来的。</p>
<h4 id="达成三星索引"><a href="#达成三星索引" class="headerlink" title="达成三星索引"></a>达成三星索引</h4><p>现在有表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer( cno <span class="type">int</span>, lname <span class="type">varchar</span>(<span class="number">10</span>), fname <span class="type">varchar</span>(<span class="number">10</span>), sex <span class="type">int</span>, weight <span class="type">int</span>, city <span class="type">varchar</span>(<span class="number">10</span>)); </span><br><span class="line"><span class="comment">-- 建立索引 </span></span><br><span class="line"><span class="keyword">create</span> index idx_cust <span class="keyword">on</span> customer(city,lname,fname,cno);</span><br></pre></td></tr></table></figure>
<p>对于下面的 SQL 而言，这是个三星索引 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cno,fname <span class="keyword">from</span> customer <span class="keyword">where</span> lname <span class="operator">=</span>’xx’ <span class="keyword">and</span> city <span class="operator">=</span>’yy’ <span class="keyword">order</span> <span class="keyword">by</span> fname;</span><br></pre></td></tr></table></figure>
<p>来评估下：<br>第一颗星：所有等值谓词的列，是组合索引的开头的列，可以把索引片缩得 很窄，符合。<br>第二颗星：<code>order by</code> 的 <code>fname</code> 字段在组合索引中且是索引自动排序好的，符合。<br>第三颗星：<code>select</code>中的 <code>cno</code> 字段、<code>fname</code> 字段在组合索引中存在，符合。</p>
<h4 id="达不成三星索引"><a href="#达不成三星索引" class="headerlink" title="达不成三星索引"></a>达不成三星索引</h4><p>现在有表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test`</span><br><span class="line">(</span><br><span class="line">    `id`        <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `user_name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `sex`       <span class="type">int</span>(<span class="number">11</span>)      <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age`       <span class="type">int</span>(<span class="number">11</span>)      <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c_date`    datetime     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>
<p>SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,sex,age <span class="keyword">from</span> test <span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">&#x27;test%&#x27;</span> <span class="keyword">and</span> sex <span class="operator">=</span><span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age</span><br></pre></td></tr></table></figure>
<p>如果建立索引<code>(user_name,sex,age)</code>：<br>​      第三颗星，满足<br>​      第一颗星，满足<br>​      第二颗星，不满足，<code>user_name</code> 采用了范围匹配，<code>sex</code>是过滤列，此时 <code>age</code> 列 无法保证有序的。<br>​      上述看到，此时索引<code>(user_name,sex,age)</code>并不能满足三星索引中的第二颗星（排序）。<br>​      于是改改，建立索引<code>(sex, age，user_name)</code>：<br>​      ​      第一颗星，不满足，只可以匹配到 <code>sex</code>，<code>sex</code> 选择性很差，意味着是一个宽索引片。<br>​      ​      第二颗星，满足，等值 <code>sex</code> 的情况下，<code>age</code> 是有序的。<br>​      ​      第三颗星，满足，<code>select</code> 查询的列都在索引列中。<br>​      对于索引<code>(sex,age，user_name)</code>可以看到，此时无法满足第一颗星，窄索引片的需求。<br>​      以上 2 个索引，都是无法同时满足三星索引设计中的三个需求的，只能尽力满足 2 个。而在多数情况下，能够满足 2 颗星，已经能缩小很大的查询范围 了，具体最终要保留那一颗星（排序星 <code>or</code> 窄索引片星），这个就需要看查询者 自己的着重点了，无法给出标准答案。</p>
<h3 id="主键是很少改变的列"><a href="#主键是很少改变的列" class="headerlink" title="主键是很少改变的列"></a>主键是很少改变的列</h3><p>​      行是按照聚集索引物理排序的，如果主键频繁改变(<code>update</code>)，物理顺序会改变，<code>MySQL</code> 要不断调整 <code>B+</code>树，并且中间可能会产生页面的分裂和合并等等，会导致性能会急剧降低。</p>
<h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p>​      <code>MySQL</code> 允许在相同列上创建多个索引，无论是有意的还是无意的。<code>MySQL</code> 需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑， 这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索 引。应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<h3 id="删除未使用的索引"><a href="#删除未使用的索引" class="headerlink" title="删除未使用的索引"></a>删除未使用的索引</h3><p>​      除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的 索引完全是累赘，建议考虑删除。</p>
<h2 id="高性能索引使用策略"><a href="#高性能索引使用策略" class="headerlink" title="高性能索引使用策略"></a>高性能索引使用策略</h2><p>先总结一下，索引的使用策略一共有13中。</p>
<ul>
<li><strong>1、 尽量全值匹配</strong></li>
<li><strong>2、最佳左前缀法则</strong></li>
<li><strong>3、 覆盖索引尽量用</strong></li>
<li><strong>4、不等于要慎用</strong></li>
<li><strong>5、Null&#x2F;Not 有影响</strong></li>
<li><strong>6、Like 查询要当心</strong></li>
<li><strong>7、字符类型加引号</strong></li>
<li><strong>8、使用索引扫描来做排序和分组</strong></li>
<li><strong>9、排序要当心</strong></li>
<li><strong>10、尽可能按主键顺序插入行</strong></li>
<li><strong>11、优化 Count 查询</strong></li>
<li><strong>12、优化 limit 分页</strong><br>附上别人的记忆总结：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全职匹配我最爱，最左前缀要遵守；</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">带头大哥不能死，中间兄弟不能断；</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">索引列上少计算，范围之后全失效；</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LIKE 百分写最右，覆盖索引不写*；</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不等空值还有 OR，索引影响要注意；</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VAR 引号不可丢， SQL 优化有诀窍。</span></span><br></pre></td></tr></table></figure>
下面针对每一种进行分析，测试：<h3 id="不在索引列上做任何操作"><a href="#不在索引列上做任何操作" class="headerlink" title="不在索引列上做任何操作"></a>不在索引列上做任何操作</h3>通常会看到一些查询不当地使用索引，或者使得 <code>MySQL</code> 无法使用已有 的索引。如果查询中的列不是独立的，则 <code>MySQL</code> 就不会使用索引。“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。<br>例如，假设 <code>order_status</code> 上有索引，但是下面这个查询无法使用 <code>order_status</code> 列的索引: <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_status <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure>
凭肉眼很容易看出 <code>WHERE</code> 中的表达式其实等价于 <code>order_status = 0</code>，但是 <code>MySQL</code> 无法自动解析这个方程式。这完全是用户行为。应该养成简化 WHERE 条件的习惯，始终将索引列单独放在比较符号的一侧。<br>下面是另一个常见的错误: <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> TO_DAYS(insert_time) <span class="operator">-</span> TO_DAYS(expire_time) <span class="operator">&lt;=</span> <span class="number">10</span>; </span><br></pre></td></tr></table></figure>
在索引列上使用函数，也是无法利用索引的。<h3 id="尽量全值匹配"><a href="#尽量全值匹配" class="headerlink" title="尽量全值匹配"></a>尽量全值匹配</h3>建立了联合索引列后，如果我们的搜索条件中的列和索引列一致的话，这种 情况就称为全值匹配，比方说下边这个查找语句： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>; </span><br></pre></td></tr></table></figure>
我们建立的<code>u_idx_day_statusr</code>索引包含的3个列在这个查询语句中都展现出 来了，联合索引中的三个列都可能被用到。<br>也许有个疑问，WHERE 子句中的几个搜索条件的顺序对查询结果 有啥影响么？也就是说如果我们调换<code>insert_time</code>, <code>order_status</code>, <code>expire_time</code>这 几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> order_status<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span> <span class="keyword">and</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span>; </span><br></pre></td></tr></table></figure>
放心，<code>MySQL</code> 没这么蠢，查询优化器会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。<br>所以，当建立了联合索引列后，能在 <code>where</code> 条件中使用索引的尽量使用。<h3 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h3>建立了联合索引列，如果搜索条件不够全值匹配怎么办？在我们的搜索语句 中也可以不用包含全部联合索引中的列，但要遵守最左前缀法则。指的是查询从 索引的最左前列开始并且不跳过索引中的列。<br>比如：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">1</span>； </span><br></pre></td></tr></table></figure>
或<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> ； </span><br></pre></td></tr></table></figure>
那为什么搜索条件中必须出现左边的列才可以使用到这个 B+树索引呢？比如下边的语句就用不到这个 <code>B+</code>树索引么？ <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_status<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure>
或<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> order_status<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br></pre></td></tr></table></figure>
<code>explain</code>查询了执行计划后，发现是全表扫描。<br>想一下，因为 <code>B+</code>树的数据页和记录先是按照 <code>insert_time</code> 列的值排序的， 在<code> insert_time</code> 列的值相同的情况下才使用 <code>order_status</code> 列进行排序，也就是说 <code>insert_time</code> 列的值不同的记录中 <code>order_status</code> 的值可能是无序的。而现在你跳过 <code>insert_time</code> 列直接根据<code>order_status</code> 的值去查找，怎么可能呢？<code>expire_time</code> 也是 一样的道理，那如果我就想在只使用<code>expire_time</code> 的值去通过 <code>B+</code>树索引进行查找 咋办呢？这好办，你再对 <code>expire_time</code> 列建一个 <code>B+</code>树索引就行了。<br>但是需要特别注意的一点是，如果我们想使用联合索引中尽可能多的列，搜 索条件中的各个列必须是联合索引中从最左边连续的列。比方说联合索引<code> u_idx_day_status</code> 中列的定义顺序是<code>insert_time</code>, <code>order_status</code>, <code>expire_time</code>，如 果我们的搜索条件中只有 <code>insert_time</code> 和 <code>expire_time</code>，而没有中间的<code> order_status</code>， <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>; </span><br></pre></td></tr></table></figure>
只能用到<code> insert_time</code> 列的索引，<code>order_status</code> 和 <code>expire_time</code> 的索引就用不上 了，道理不用多说了。<h3 id="范围条件放最后"><a href="#范围条件放最后" class="headerlink" title="范围条件放最后"></a>范围条件放最后</h3>这一点，也是针对联合索引来说的，前面我们反复强调过，所有记录都是按 照索引列的值从小到大的顺序排好序的，而联合索引则是按创建索引时的顺序进 行分组排序。<br>比如：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut <span class="keyword">where</span> insert_time<span class="operator">&gt;</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> insert_time<span class="operator">&lt;</span><span class="string">&#x27;2021-03-22 18:35:00&#x27;</span>;</span><br></pre></td></tr></table></figure>
由于<code>B+</code>树中的数据页和记录是先按 <code>insert_time</code> 列排序的，所以我们上边的 查询过程其实是这样的：<br>找到 <code>insert_time</code> 值为<code>2021-03-22 18:23:42</code>的记录。<br>找到 <code>insert_time</code> 值为<code>2021-03-22 18:35:00</code>的记录。<br>由于所有记录都是由链表连起来的，所以他们之间的记录都可以很容易的取 出来，找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。<br>但是如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行 范围查找的时候才能用到 <code>B+</code>树索引： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut <span class="keyword">where</span> insert_time<span class="operator">&gt;</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> insert_time<span class="operator">&lt;</span><span class="string">&#x27;2021-03-22 18:35:00&#x27;</span> <span class="keyword">and</span> order_status <span class="operator">&gt;</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="覆盖索引尽量用"><a href="#覆盖索引尽量用" class="headerlink" title="覆盖索引尽量用"></a>覆盖索引尽量用</h3><h3 id="不等于要慎用"><a href="#不等于要慎用" class="headerlink" title="不等于要慎用"></a>不等于要慎用</h3><h3 id="Null-x2F-Not-有影响"><a href="#Null-x2F-Not-有影响" class="headerlink" title="Null&#x2F;Not 有影响"></a>Null&#x2F;Not 有影响</h3><h3 id="Like-查询要当心"><a href="#Like-查询要当心" class="headerlink" title="Like 查询要当心"></a>Like 查询要当心</h3><h3 id="字符类型加引号"><a href="#字符类型加引号" class="headerlink" title="字符类型加引号"></a>字符类型加引号</h3><h3 id="使用索引扫描来做排序和分组"><a href="#使用索引扫描来做排序和分组" class="headerlink" title="使用索引扫描来做排序和分组"></a>使用索引扫描来做排序和分组</h3><h3 id="排序要当心"><a href="#排序要当心" class="headerlink" title="排序要当心"></a>排序要当心</h3><h3 id="尽可能按主键顺序插入行"><a href="#尽可能按主键顺序插入行" class="headerlink" title="尽可能按主键顺序插入行"></a>尽可能按主键顺序插入行</h3><h3 id="优化-Count-查询"><a href="#优化-Count-查询" class="headerlink" title="优化 Count 查询"></a>优化 Count 查询</h3><h3 id="优化-limit-分页"><a href="#优化-limit-分页" class="headerlink" title="优化 limit 分页"></a>优化 limit 分页</h3></div><div class="article-licensing box"><div class="licensing-title"><p>2021-05-13-MySQL 索引总结</p><p><a href="https://peialan.github.io/2021/05/13/2021-04-30-MySQL索引复习/">https://peialan.github.io/2021/05/13/2021-04-30-MySQL索引复习/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://peialan.github.io"><p>EllisonPei</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-03-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2021/04/27/2021-04-27-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%AB%E7%85%A7%E5%A4%87%E4%BB%BD/" target="_blank">2021-04-27-MySQL数据库快照备份</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/02/23/2022-02-23%E2%80%94%E9%A1%B9%E2%BD%AC%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/" target="_blank">2022-02-23—项⽬如何排查JVM问题</a><br></span><span>  2.<a class="is-size-6" href="/2022/03/02/2022-03-02-Spring%20FrameWork%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" target="_blank">2022-03-02—spring Frame Work 5.3.10源码编译</a><br></span><span>  3.<a class="is-size-6" href="/2022/03/18/2022-03-18-redis%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/" target="_blank">2022-03-18—Redis高并发场景问题解析</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/reward/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/reward/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/23/2021-08-23-%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E6%96%B9%E6%A1%88/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">2021-08-23—双机热备实现方案</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/27/2021-04-27-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%AB%E7%85%A7%E5%A4%87%E4%BB%BD/"><span class="level-item">2021-04-27-MySQL数据库快照备份</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div class="content" id="comment-container"></div><script>var valine = new Valine({
            el: '#comment-container' ,
            notify: false,
            verify: false,
            appId: 'iMJmYJpiQTmDIHuXctJxx4EF-gzGzoHsz',
            appKey: 'MDrcq4xdFWWsWdOjPQOYalu9',
            placeholder: '留下您的高见！',
            avatar: 'mp',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false,
            path:'/2021/05/13/2021-04-30-MySQL索引复习/',
            lang:'zh-CN',
            enableQQ:true,
            requiredFields:["nick","mail","link"]
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#MySQL-索引总结"><span>MySQL 索引总结</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#生活中的索引"><span>生活中的索引</span></a></li><li><a class="is-flex is-mobile" href="#MySQL中的索引"><span>MySQL中的索引</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#B-树"><span>B+树</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#InnoDB中的索引"><span>InnoDB中的索引</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#聚集索引-x2F-聚簇索引"><span>聚集索引/聚簇索引</span></a></li><li><a class="is-flex is-mobile" href="#辅助索引-x2F-二级索引"><span>辅助索引/二级索引</span></a></li><li><a class="is-flex is-mobile" href="#回表"><span>回表</span></a></li><li><a class="is-flex is-mobile" href="#联合索引-x2F-复合索引"><span>联合索引/复合索引</span></a></li><li><a class="is-flex is-mobile" href="#覆盖索引-x2F-索引覆盖"><span>覆盖索引/索引覆盖</span></a></li><li><a class="is-flex is-mobile" href="#自适应哈希索引"><span>自适应哈希索引</span></a></li><li><a class="is-flex is-mobile" href="#全文检索之倒排索引"><span>全文检索之倒排索引</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#索引在查询中的使用"><span>索引在查询中的使用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#扫描区间"><span>扫描区间</span></a></li><li><a class="is-flex is-mobile" href="#范围区间扫描"><span>范围区间扫描</span></a></li><li><a class="is-flex is-mobile" href="#所有搜索条件都可以使用某个索引的情况"><span>所有搜索条件都可以使用某个索引的情况</span></a></li><li><a class="is-flex is-mobile" href="#有的搜索条件无法使用索引的情况"><span>有的搜索条件无法使用索引的情况</span></a></li><li><a class="is-flex is-mobile" href="#使用联合索引执行查询时对应的扫描区间"><span>使用联合索引执行查询时对应的扫描区间</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#创建和删除索引的语句"><span>创建和删除索引的语句</span></a></li><li><a class="is-flex is-mobile" href="#索引的代价"><span>索引的代价</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#空间上的代价"><span>空间上的代价</span></a></li><li><a class="is-flex is-mobile" href="#时间上的代价"><span>时间上的代价</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#高性能索引创建策略"><span>高性能索引创建策略</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#索引列的类型尽量小"><span>索引列的类型尽量小</span></a></li><li><a class="is-flex is-mobile" href="#索引选择性和前缀索引"><span>索引选择性和前缀索引</span></a></li><li><a class="is-flex is-mobile" href="#只为用于搜索、排序或分组的列创建索引"><span>只为用于搜索、排序或分组的列创建索引</span></a></li><li><a class="is-flex is-mobile" href="#多列索引"><span>多列索引</span></a></li><li><a class="is-flex is-mobile" href="#达不成三星索引"><span>达不成三星索引</span></a></li><li><a class="is-flex is-mobile" href="#主键是很少改变的列"><span>主键是很少改变的列</span></a></li><li><a class="is-flex is-mobile" href="#冗余和重复索引"><span>冗余和重复索引</span></a></li><li><a class="is-flex is-mobile" href="#删除未使用的索引"><span>删除未使用的索引</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#高性能索引使用策略"><span>高性能索引使用策略</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#不在索引列上做任何操作"><span>不在索引列上做任何操作</span></a></li><li><a class="is-flex is-mobile" href="#尽量全值匹配"><span>尽量全值匹配</span></a></li><li><a class="is-flex is-mobile" href="#最佳左前缀法则"><span>最佳左前缀法则</span></a></li><li><a class="is-flex is-mobile" href="#范围条件放最后"><span>范围条件放最后</span></a></li><li><a class="is-flex is-mobile" href="#覆盖索引尽量用"><span>覆盖索引尽量用</span></a></li><li><a class="is-flex is-mobile" href="#不等于要慎用"><span>不等于要慎用</span></a></li><li><a class="is-flex is-mobile" href="#Null-x2F-Not-有影响"><span>Null/Not 有影响</span></a></li><li><a class="is-flex is-mobile" href="#Like-查询要当心"><span>Like 查询要当心</span></a></li><li><a class="is-flex is-mobile" href="#字符类型加引号"><span>字符类型加引号</span></a></li><li><a class="is-flex is-mobile" href="#使用索引扫描来做排序和分组"><span>使用索引扫描来做排序和分组</span></a></li><li><a class="is-flex is-mobile" href="#排序要当心"><span>排序要当心</span></a></li><li><a class="is-flex is-mobile" href="#尽可能按主键顺序插入行"><span>尽可能按主键顺序插入行</span></a></li><li><a class="is-flex is-mobile" href="#优化-Count-查询"><span>优化 Count 查询</span></a></li><li><a class="is-flex is-mobile" href="#优化-limit-分页"><span>优化 limit 分页</span></a></li></ul></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png" alt="北北の酱"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">北北の酱</p><p class="is-size-6 is-block">尚未执佩剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">29</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">58</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PeiAlan" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PeiAlan"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:ellisonpei@foxmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Next" href="https://blog.lovewinter.top/about/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.jianshu.com/u/89ec42d8a581" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span><span class="level-right"><span class="level-item tag">www.jianshu.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-10T15:07:56.000Z">2022-08-10</time></p><p class="title"><a href="/2022/08/10/2022-08-10-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%93%E5%8C%85%E8%BF%87%E7%A8%8B/">2022-08-10-Linux服务器抓包过程</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T15:07:56.000Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/2022-05-10-%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">2022-05-10-时区问题解决方案</a></p><p class="categories"><a href="/categories/TimeZone/">TimeZone</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-18T12:07:56.000Z">2022-03-18</time></p><p class="title"><a href="/2022/03/18/2022-03-18-redis%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/">2022-03-18—Redis高并发场景问题解析</a></p><p class="categories"><a href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-02T11:33:56.000Z">2022-03-02</time></p><p class="title"><a href="/2022/03/02/2022-03-02-Spring%20FrameWork%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">2022-03-02—spring Frame Work 5.3.10源码编译</a></p><p class="categories"><a href="/categories/Spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-23T01:33:56.000Z">2022-02-23</time></p><p class="title"><a href="/2022/02/23/2022-02-23%E2%80%94%E9%A1%B9%E2%BD%AC%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/">2022-02-23—项⽬如何排查JVM问题</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/DevTools/"><span class="level-start"><span class="level-item">DevTools</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ELK/"><span class="level-start"><span class="level-item">ELK</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MQ/"><span class="level-start"><span class="level-item">MQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Maven/"><span class="level-start"><span class="level-item">Maven</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mysql/"><span class="level-start"><span class="level-item">Mysql</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Oracle/"><span class="level-start"><span class="level-item">Oracle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/tomcat/"><span class="tag">tomcat</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java8/"><span class="tag">Java8</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java8/"><span class="tag">java8</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jdk/"><span class="tag">jdk</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9/"><span class="tag">linux分区扩容</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springboot/"><span class="tag">springboot</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssl/"><span class="tag">ssl</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AOP/"><span class="tag">AOP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AQS/"><span class="tag">AQS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JUC/"><span class="tag">JUC</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MQ/"><span class="tag">MQ</span><span class="tag is-grey-lightest">1</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m4uyne2jj20m606cgm1.jpg" alt="⋆北北の酱⋆" height="28"></a><p class="size-small"><span>&copy; 2022 EllisonPei</span>  Powered by <a href="https://blog.lovewinter.top/" target="_blank">EllisonPei</a>  <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">辽ICP备16008116号</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2019/11/02 00:00:00')", 250,"");</script><br></span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2227373273" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('iMJmYJpiQTmDIHuXctJxx4EF-gzGzoHsz','MDrcq4xdFWWsWdOjPQOYalu9','北北の酱','undefined',true);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('iMJmYJpiQTmDIHuXctJxx4EF-gzGzoHsz','MDrcq4xdFWWsWdOjPQOYalu9','北北の酱','undefined',true);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>