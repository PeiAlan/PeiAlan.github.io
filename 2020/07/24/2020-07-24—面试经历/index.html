<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>2020-07-24—面试经历 - ⋆北北の酱⋆</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="⋆北北の酱⋆"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="⋆北北の酱⋆"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="尚未执佩剑，转眼即江湖"><meta property="og:type" content="blog"><meta property="og:title" content="北北の酱"><meta property="og:url" content="https://blog.lovewinter.top/"><meta property="og:site_name" content="北北の酱"><meta property="og:description" content="尚未执佩剑，转眼即江湖"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><meta property="article:published_time" content="2020-07-24T09:58:20.000Z"><meta property="article:modified_time" content="2022-03-25T06:42:28.530Z"><meta property="article:author" content="ellisonPei"><meta property="article:tag" content="面试"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://peialan.github.io/2020/07/24/2020-07-24%E2%80%94%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"},"headline":"北北の酱","image":["https://peialan.github.io/blog/medias/blog/jvm/GC.png","https://peialan.github.io/blog/medias/blog/jvm/JVM-laji.png","https://peialan.github.io/blog/medias/blog/jvm/coping.png","https://peialan.github.io/blog/medias/blog/jvm/STW.png","https://peialan.github.io/blog/medias/blog/jvm/CMS.png","https://peialan.github.io/blog/medias/blog/jvm/G1.png"],"datePublished":"2020-07-24T09:58:20.000Z","dateModified":"2022-03-25T06:42:28.530Z","author":{"@type":"Person","name":"EllisonPei"},"description":"尚未执佩剑，转眼即江湖"}</script><link rel="canonical" href="https://peialan.github.io/2020/07/24/2020-07-24%E2%80%94%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><script async="" referrerpolicy="no-referrer" src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="/js/md5.min.js"></script><meta name="generator" content="Hexo 5.4.1"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m4uyne2jj20m606cgm1.jpg" alt="⋆北北の酱⋆" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/self-talking">碎碎念</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeiAlan"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-07-24  <a class="commentCountImg" href="/2020/07/24/2020-07-24%E2%80%94%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/#comment-container"><span class="display-none-class">/2020/07/24/2020-07-24—面试经历/</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="18d6d1fa93b46522a66263c3c3d0bdf8">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>41 分钟  <i class="fas fa-pencil-alt"> </i>6.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile">2020-07-24—面试经历</h1><div class="content"><h2 id="2020-07-24-面试经历（全程1个多小时）"><a href="#2020-07-24-面试经历（全程1个多小时）" class="headerlink" title="2020-07-24 面试经历（全程1个多小时）"></a>2020-07-24 面试经历（全程1个多小时）</h2><p>​        这次面试，让我意识到了，关于各种并发上，自己的实战经验有很大的不足之处，自己以后，在学习的同时，也要多多注意代码的编写。以及各种问题的实践。下面把面试过程回忆一下，也是不错的巩固过程。</p>
<span id="more"></span>

<h2 id="一、自我介绍"><a href="#一、自我介绍" class="headerlink" title="一、自我介绍"></a>一、自我介绍</h2><h2 id="二、项目介绍，项目细节（业务，activiti工作流）"><a href="#二、项目介绍，项目细节（业务，activiti工作流）" class="headerlink" title="二、项目介绍，项目细节（业务，activiti工作流）"></a>二、项目介绍，项目细节（业务，activiti工作流）</h2><p>​        activiti主要问，act表的细节，中间问了是否改动过act的原表，由于自己没有改动的经验，所以当时说的没有。</p>
<h2 id="三、从项目里延伸"><a href="#三、从项目里延伸" class="headerlink" title="三、从项目里延伸"></a>三、从项目里延伸</h2><p>docker    基本命令 和 dockerfile，在这复习一下吧：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> &#123;base 镜像&#125; </span><br><span class="line">	必须放在 DOckerfile 的第一行，表示从哪个 baseimage 开始构建 </span><br><span class="line">	</span><br><span class="line"><span class="keyword">MAINTAINER</span></span><br><span class="line">	可选的，用来标识 image 作者的地方 </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">		RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。 </span></span><br><span class="line">		第一层 <span class="keyword">RUN</span><span class="language-bash"> command1 的执行仅仅是当前进程，一个内存上的变化而已，其结果不会造成任何文件。 </span></span><br><span class="line">		而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 而如果需要将两条命令或者多条命令联合起来执行需要加上&amp;&amp;。 </span><br><span class="line">如：cd /usr/local/src &amp;&amp; wget xxxxxxx </span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> </span></span><br><span class="line">		的作用是作为执行 container 时候的默认行为（容器默认的启动命令） 当运行 container 的时候声明了 command，则不再用 image 中的 <span class="keyword">CMD</span><span class="language-bash"> 默认所定义的命令一个 Dockerfile 中只能有一个有效的 CMD，当定义多个 CMD 的时候，只有最后一个才会起作用.</span></span><br><span class="line">		</span><br><span class="line"><span class="keyword">EXPOSE</span> </span><br><span class="line">		<span class="keyword">EXPOSE</span>:指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个 </span><br><span class="line">声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助 </span><br><span class="line">镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机 </span><br><span class="line">端口映射时，也就是 docker <span class="keyword">run</span><span class="language-bash"> -P 时，会自动随机映射 EXPOSE 的端口。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">entrypoint</span><span class="language-bash"> </span></span><br><span class="line">		<span class="keyword">entrypoint</span><span class="language-bash">:的作用是，把整个 container 变成可执行的文件，且不能够通过替换 CMD 的方 </span></span><br><span class="line">法来改变创建 container 的方式。但是可以通过参数传递的方法影响到 container 内部每个Dockerfile 只能够包含一个 <span class="keyword">entrypoint</span><span class="language-bash">，多个 entrypoint 只有最后一个有效当定义了 entrypoint 以后，CMD 只能够作为参数进行传递 .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> &amp; COPY </span></span><br><span class="line">		把 host 上的文件或者目录复制到 image 中（能够进行自动解压压缩包）</span><br><span class="line"><span class="keyword">ENV</span></span><br><span class="line">		用来设置环境变量，后续的 <span class="keyword">RUN</span><span class="language-bash"> 可以使用它所创建的环境变量 </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> </span></span><br><span class="line">    用来指定当前工作目录（或者称为当前目录） </span><br><span class="line"><span class="keyword">USER</span></span><br><span class="line">		运行 <span class="keyword">RUN</span><span class="language-bash"> 指令的用户 </span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">		用来创建一个在 image 之外的 mount point</span></span><br></pre></td></tr></table></figure>



<h2 id="四、Java基础"><a href="#四、Java基础" class="headerlink" title="四、Java基础"></a>四、Java基础</h2><h3 id="1、集合"><a href="#1、集合" class="headerlink" title="1、集合"></a>1、集合</h3><p>list的实现类 —- ArrayList、LinkedList 区别？ArrayList 添加数据的原理（说逻辑）？</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Array(数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</span><br><span class="line">Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据, (因为删除数据以后, 需要把后面所有的数据前移)</span><br><span class="line">缺点: 数组初始化必须指定初始化的长度, 否则报错</span><br><span class="line">例如: </span><br><span class="line">int[] a = new int[4];//推荐使用int[] 这种方式初始化 </span><br><span class="line">int c[] = &#123;23,43,56,78&#125;;//长度：4，索引范围：[0,3]</span><br><span class="line"></span><br><span class="line">List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</span><br><span class="line">List有两个重要的实现类：ArrayList和LinkedList</span><br><span class="line">ArrayList: 可以看作是能够自动增长容量的数组</span><br><span class="line">ArrayList的toArray方法返回一个数组</span><br><span class="line">ArrayList的asList方法返回一个列表</span><br><span class="line">ArrayList底层的实现是Array, 数组扩容实现</span><br><span class="line">LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于</span><br><span class="line">ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</span><br></pre></td></tr></table></figure>

<p>ArrayList 添加数据的原理（说逻辑）?</p>
<p>​    这个问题我有点懵逼，  我以为要问的就是add（）方法，可是不是，其实是add的逻辑。</p>
<p>实现逻辑就是：</p>
<p>调用add（int index, E element），然后先调用rangeCheckForAdd(index);来确保容量，容量不够抛出throw new IndexOutOfBoundsException异常，然后就是将数据填入数组，最后size++。</p>
<p>整体大致这样，详细实现还得看源码，我在也找到了大致的流程图：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Chsy/p/12593448.html">https://www.cnblogs.com/Chsy/p/12593448.html</a></p>
<h3 id="2、引用类型"><a href="#2、引用类型" class="headerlink" title="2、引用类型"></a>2、引用类型</h3><p>​        刚开始有点愣，其实指的就是  强软弱虚 ，</p>
<h3 id="3、说一说Hashset"><a href="#3、说一说Hashset" class="headerlink" title="3、说一说Hashset"></a>3、说一说Hashset</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">哈希表边存放的是哈希值。 </span><br><span class="line">HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ， HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</span><br><span class="line">哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相</span><br><span class="line">同的元素放在一个哈希桶中）。也就是哈希一样的存一列。 如图 1 表示 hashCode 值不相同的情</span><br><span class="line">况； 图 2 表示 hashCode 值相同，但 equals 不相同的情况。</span><br></pre></td></tr></table></figure>



<h3 id="4、说一说HashMap-1-7和1-8-，扩容机制-put操作的过程-答的不好"><a href="#4、说一说HashMap-1-7和1-8-，扩容机制-put操作的过程-答的不好" class="headerlink" title="4、说一说HashMap(1.7和1.8)，扩容机制,put操作的过程(答的不好)"></a>4、说一说HashMap(1.7和1.8)，扩容机制,put操作的过程(答的不好)</h3><p>1.7的put</p>
<p>简单地说就是把key值进行hash计算，然后判断hash表中是否存在，若存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、ConcurrentHashMap"><a href="#五、ConcurrentHashMap" class="headerlink" title="五、ConcurrentHashMap"></a>五、ConcurrentHashMap</h2><h3 id="1-8-ConcurrentHashMap的结构？"><a href="#1-8-ConcurrentHashMap的结构？" class="headerlink" title="1.8 ConcurrentHashMap的结构？"></a><strong>1.8 ConcurrentHashMap的结构？</strong></h3><p>​            Node + 链表 + 红黑树，使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结 点）（实现 Map.Entry&lt;K,V&gt;）。锁粒度降低了。</p>
<h3 id="针对-ConcurrentHashMap锁机制具体分析（JDK-1-7-VS-JDK-1-8）？"><a href="#针对-ConcurrentHashMap锁机制具体分析（JDK-1-7-VS-JDK-1-8）？" class="headerlink" title="针对 ConcurrentHashMap锁机制具体分析（JDK 1.7 VS JDK 1.8）？"></a><strong>针对 ConcurrentHashMap锁机制具体分析（JDK 1.7 VS JDK 1.8）？</strong></h3><p>JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表 </p>
<p>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。 </p>
<p>①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 </p>
<p>Segment 对象守护每个散列映射表的若干个桶； </p>
<p>②、HashEntry 用来封装映射表的键-值对； </p>
<p>③、每个桶是由若干个 HashEntry 对象链接起来的链表。 </p>
<p>JDK 1.8 中，采用 Node + CAS + Synchronized 来保证并发安全。取消类 </p>
<p>Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超 </p>
<p>过 TREEIFY_THRESHOLD 时，链表转换为红黑树，提升性能。底层变更为数组 + </p>
<p>链表 + 红黑树。</p>
<h3 id="然后接着问了-concurrentHashMap-中哪个地方用了Synchronized，哪个地方用了CAS？"><a href="#然后接着问了-concurrentHashMap-中哪个地方用了Synchronized，哪个地方用了CAS？" class="headerlink" title="然后接着问了 concurrentHashMap 中哪个地方用了Synchronized，哪个地方用了CAS？"></a><strong>然后接着问了 concurrentHashMap 中哪个地方用了Synchronized，哪个地方用了CAS？</strong></h3><p>​        我一时间没想起来，面试官给我提示才想起来，</p>
<p>​        Synchronized锁的是一个Node节点，然后进行的put操作，里面有个putIfAbsent的实现，然后就是利用尾插法向链表尾部插入数据。</p>
<p>​        CAS调用的地方实在addCount( ) ; 中调用了硬件级别的U.compareAndSwap（）方法。</p>
<h2 id="六、线程问题"><a href="#六、线程问题" class="headerlink" title="六、线程问题"></a>六、线程问题</h2><p>接下来问了些关于线程的问题，问了线程池的基本类型、线程池的参数、线程池的工作原理？</p>
<h3 id="线程池的基本类型："><a href="#线程池的基本类型：" class="headerlink" title="线程池的基本类型："></a>线程池的基本类型：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">FixedThreadPool :</span><br><span class="line">		详解 创建使用固定线程数的 FixedThreadPool 的 API。适用于为了满足资源管理的 需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为创建 FixedThreadPool 时指定的参数 nThreads。 当线程池中的线程数大于 corePoolSize 时，keepAliveTime 为多余的空闲线程 等待新任务的 最长时间，超过这个时间后多余的线程将被终止。这里把 keepAliveTime 设 置为 0L，意味着多余的空闲线程会被立即终止。 FixedThreadPool 使用有界队列 LinkedBlockingQueue 作为线程池的工作队列 （队列的容量为 Integer.MAX<span class="built_in">_</span>VALUE）。 </span><br><span class="line">		</span><br><span class="line">SingleThreadExecutor :</span><br><span class="line">		创建使用单个线程的 SingleThread-Executor 的 API，于需要保证顺序地执行 各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。 corePoolSize 和 maximumPoolSize 被设置为 1。其他参数与 FixedThreadPool 相同。SingleThreadExecutor 使用有界队列 LinkedBlockingQueue 作为线程池的工 作队列（队列的容量为 Integer.MAX<span class="built_in">_</span>VALUE）。 </span><br><span class="line">		</span><br><span class="line">CachedThreadPool :</span><br><span class="line">		创建一个会根据需要创建新线程的 CachedThreadPool 的 API。大小无界的线 程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。 </span><br><span class="line">		corePoolSize 被设置为 0，即 corePool 为空；</span><br><span class="line">		maximumPoolSize 被设置为 Integer.MAX<span class="built_in">_</span>VALUE。</span><br><span class="line">		这里把 keepAliveTime 设置为 60L，意味着 CachedThreadPool 中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。 </span><br><span class="line">		FixedThreadPool 和 SingleThreadExecutor 使用有界队列 LinkedBlockingQueue 作为线程池的工作队列。CachedThreadPool 使用没有容量的 SynchronousQueue 作为线程池的工作队列，但 CachedThreadPool 的 maximumPool 是无界的。这意味着，如果主线程提交任务的速度高于 maximumPool 中线程处理任务的速度时， CachedThreadPool 会不断创建新线程。极端情况下，CachedThreadPool 会因为创 建过多线程而耗尽 CPU 和内存资源。 </span><br><span class="line">		</span><br><span class="line">WorkStealingPool :</span><br><span class="line">		利用所有运行的处理器数目来创建一个工作窃取的线程池，使用 forkjoin 实 现</span><br><span class="line">		</span><br><span class="line">ScheduledThreadPoolExecutor :</span><br><span class="line">			使用工厂类 Executors 来创建。Executors 可以创建 2 种类型的ScheduledThreadPoolExecutor，如下。 </span><br><span class="line">			•ScheduledThreadPoolExecutor。包含若干个线程的 ScheduledThreadPoolExecutor。 </span><br><span class="line">			•SingleThreadScheduledExecutor。只包含一个线程的 ScheduledThreadPoolExecutor。 </span><br><span class="line">			ScheduledThreadPoolExecutor 适用于需要多个后台线程执行周期任务，同时 为了满足资源管理的需求而需要限制后台线程的数量的应用场景。 </span><br><span class="line">			SingleThreadScheduledExecutor 适用于需要单个后台线程执行周期任务，同 时需要保证顺序地执行各个任务的应用场景。</span><br></pre></td></tr></table></figure>



<h3 id="线程池的参数："><a href="#线程池的参数：" class="headerlink" title="线程池的参数："></a>线程池的参数：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">corePoolSize ：</span><br><span class="line">		线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任 务，直到当前线程数等于 corePoolSize； 如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等 待被执行； 如果执行了线程池的 prestartAllCoreThreads()方法，线程池会提前创建并启 动所有核心线程。</span><br><span class="line">maximumPoolSize ：</span><br><span class="line">		线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则 创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize </span><br><span class="line">	</span><br><span class="line">keepAliveTime ：</span><br><span class="line">		线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认 情况下，该参数只在线程数大于 corePoolSize 时才有用 </span><br><span class="line">		</span><br><span class="line">TimeUnit： keepAliveTime 的时间单位 </span><br><span class="line"></span><br><span class="line">workQueue ：</span><br><span class="line">		workQueue 必须是 BlockingQueue 阻塞队列。当线程池中的线程数超过它的corePoolSize 的时候，线程会进入阻塞队列进行阻塞等待。通过 workQueue，线 程池实现了阻塞功能 </span><br><span class="line">workQueue,用于保存等待执行的任务的阻塞队列，一般来说，我们应该尽量使用有界队 列，因为使用无界队列作为工作队列会对线程池带来如下影响。 </span><br><span class="line">			1）当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待， 因此线程池中的线程数不会超过 corePoolSize。 </span><br><span class="line">			2）由于 1，使用无界队列时 maximumPoolSize 将是一个无效参数。 </span><br><span class="line">			3）由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数。 </span><br><span class="line">			4）更重要的，使用无界 queue 可能会耗尽系统资源，有界队列则有助于防 止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范 围。所以我们一般会使用，ArrayBlockingQueue、LinkedBlockingQueue、 SynchronousQueue、PriorityBlockingQueue。 </span><br><span class="line">		</span><br><span class="line">threadFactory ：</span><br><span class="line">		创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具 有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有 的线程为守护线程。 静态工厂里默认的 threadFactory，线程的命名规则是“pool-数字 -thread-数字”。 </span><br><span class="line">		</span><br><span class="line">RejectedExecutionHandler ：</span><br><span class="line">		线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提 交任务，必须采取一种策略处理该任务，线程池提供了 4 种策略：</span><br><span class="line">（1）AbortPolicy：直接抛出异常，默认策略； </span><br><span class="line">（2）CallerRunsPolicy：用调用者所在的线程来执行任务； </span><br><span class="line">（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； </span><br><span class="line">（4）DiscardPolicy：直接丢弃任务； 当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和 策略，如记录日志或持久化存储不能处理的任务。</span><br></pre></td></tr></table></figure>



<h3 id="线程池的工作原理："><a href="#线程池的工作原理：" class="headerlink" title="线程池的工作原理："></a>线程池的工作原理：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1）如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务（注意， 执行这一步骤需要获取全局锁）。 </span><br><span class="line">2）如果运行的线程等于或多于 corePoolSize，则将任务加入 BlockingQueue。 </span><br><span class="line">3）如果无法将任务加入 BlockingQueue（队列已满），则创建新的线程来处 理任务。</span><br><span class="line">4）如果创建新线程将使当前运行的线程超出 maximumPoolSize，任务将被 拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法。</span><br></pre></td></tr></table></figure>



<h2 id="七、JVM"><a href="#七、JVM" class="headerlink" title="七、JVM"></a>七、JVM</h2><p>分别问了内存结构、判断对象存活、各种引用对GC的影响、垃圾回收算法、垃圾回收器。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a><strong>内存结构</strong></h3><p>自己画了图：</p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f198920e401fd181ad55cf1">https://www.processon.com/view/link/5f198920e401fd181ad55cf1</a></p>
<h3 id="判断对象存活"><a href="#判断对象存活" class="headerlink" title="判断对象存活"></a><strong>判断对象存活</strong></h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">JVM采用可达性分析算法，通过GCRoots向下搜索，会产生Reference Chain的链条，当一个对象不与GCRoot有任何关系时，就会判断为垃圾。</span><br><span class="line">		</span><br><span class="line">接着提问：GCRoots有哪些？</span><br><span class="line">作为 GC Roots 的对象包括下面几种（重点是前面 4 种）： </span><br><span class="line">1、 虚拟机栈（栈帧中的本地变量表）中引用的对象；各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。 </span><br><span class="line">2、 方法区中类静态属性引用的对象；java 类的引用类型静态变量。 </span><br><span class="line">3、 方法区中常量引用的对象；比如：字符串常量池里的引用。 </span><br><span class="line">4、 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。 </span><br><span class="line">5、 JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。（非重点） </span><br><span class="line">6、 所有被同步锁(synchronized 关键)持有的对象。（非重点） </span><br><span class="line">7、 JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等（非重点） </span><br><span class="line">8、 JVM 实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代的对象，这个后续会细讲，先大致了解概念）（非重点）</span><br></pre></td></tr></table></figure>



<h3 id="各种引用对GC的影响"><a href="#各种引用对GC的影响" class="headerlink" title="各种引用对GC的影响"></a><strong>各种引用对GC的影响</strong></h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">强引用 ：</span><br><span class="line">		一般的 Object obj = new Object() ，就属于强引用。在任何情况下，只有有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。 </span><br><span class="line">		</span><br><span class="line">软引用 SoftReference ：</span><br><span class="line">		一些有用但是并非必需，用软引用关联的对象，系统将要发生内存溢出（OuyOfMemory）之前，这些对象就会被回收（如果这次回收后还是没有足够的 空间，才会抛出内存溢出）</span><br><span class="line">		</span><br><span class="line">弱引用 WeakReference ：</span><br><span class="line">		一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC 发生时，不管内存够不够，都会被回收。</span><br><span class="line">		</span><br><span class="line">虚引用 PhantomReference ：</span><br><span class="line">		幽灵引用，最弱（随时会被回收掉） 垃圾回收的时候收到一个通知，就是为了监控垃圾回收器是否正常工作。</span><br></pre></td></tr></table></figure>



<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">复制算法（Copying）：</span><br><span class="line">		将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使 用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可， 实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。 但是要注意：内存移动是必须实打实的移动（复制），所以对应的引用(直接指针)需要调整。 复制回收算法适合于新生代，因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高，另外一半的一次性清理是很快的。</span><br><span class="line"></span><br><span class="line">标记-清除算法（Mark-Sweep）： </span><br><span class="line">		算法分为“标记”和“清除”两个阶段：</span><br><span class="line">		首先扫描所有对象标记出需要回收的对象，在标记完成后扫描回收所有被标记的对象，所以需要扫描两遍。 </span><br><span class="line">		回收效率略低，如果大部分对象是朝生夕死，那么回收效率降低，因为需要大量标记对象和回收对象，对比复制回收效率要低。 </span><br><span class="line">		它的主要问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连 续内存而不得不提前触发另一次垃圾回收动作。 回收的时候如果需要回收的对象越多，需要做的标记和清除的工作越多，所以标记清除算法适用于老年代。 </span><br><span class="line"></span><br><span class="line">标记-整理算法（Mark-Compact） ：</span><br><span class="line">		首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端 边界以外的内存。</span><br><span class="line">		标记整理算法虽然没有内存碎片，但是效率偏低。 我们看到标记整理与标记清除算法的区别主要在于对象的移动。对象移动不单单会加重系统负担，同时需要全程暂停用户线程才能进行，同时所有引用 对象的地方都需要更新（直接指针需要调整）。 所以看到，老年代采用的标记整理算法与标记清除算法，各有优点，各有缺点。</span><br></pre></td></tr></table></figure>



<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a><strong>垃圾回收器</strong></h3><p>自己花了图：<a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f198920e401fd181ad55cf1">https://www.processon.com/view/link/5f198920e401fd181ad55cf1</a></p>
<p>每个回收器的执行顺序，也参考了别人的图：</p>
<p><img src="/blog/medias/blog/jvm/GC.png" alt="GC详解"></p>
<p><img src="/blog/medias/blog/jvm/JVM-laji.png" alt="JVM各种垃圾回收器"></p>
<p><img src="/blog/medias/blog/jvm/coping.png" alt="垃圾回收算法——复制算法"></p>
<p><img src="/blog/medias/blog/jvm/STW.png" alt="STW"></p>
<p><img src="/blog/medias/blog/jvm/CMS.png" alt="CMS垃圾回收器"></p>
<p><img src="/blog/medias/blog/jvm/G1.png" alt="G1垃圾回收器"></p>
<h2 id="八、接着问了MySQL"><a href="#八、接着问了MySQL" class="headerlink" title="八、接着问了MySQL"></a>八、接着问了MySQL</h2><h3 id="B-树："><a href="#B-树：" class="headerlink" title="B+ 树："></a>B+ 树：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">数据只存储在叶子节点上，非叶子节点只保存索引信息； </span><br><span class="line">		◦ 非叶子节点（索引节点）存储的只是一个 Flag，不保存实际数据记录； </span><br><span class="line">		◦ 索引节点指示该节点的左子树比这个 Flag 小，而右子树大于等于这个 Flag </span><br><span class="line">叶子节点本身按照数据的升序排序进行链接(串联起来)； </span><br><span class="line">		◦ 叶子节点中的数据在 物理存储上是无序 的，仅仅是在 逻辑上有序 （通过指针串在一 起）；</span><br><span class="line">B+树的作用 </span><br><span class="line">		 在块设备上，通过 B+树可以有效的存储数据； </span><br><span class="line">		 所有记录都存储在叶子节点上，非叶子(non-leaf)存储索引(keys)信息； </span><br><span class="line">		 B+树含有非常高的扇出（fanout），通常超过 100，在查找一个记录时，可以有效的减 少 IO 操作；</span><br><span class="line">B+树的扇出</span><br><span class="line">	扇出 :是每个索引节点(Non-LeafPage)指向每个叶子节点(LeafPage)的指针 </span><br><span class="line">	扇出数 = 索引节点(Non-LeafPage)可存储的最大关键字个数 + 1</span><br></pre></td></tr></table></figure>
<h3 id="MySQL锁："><a href="#MySQL锁：" class="headerlink" title="MySQL锁："></a>MySQL锁：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表级锁：</span><br><span class="line">		开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发 度最低。 </span><br><span class="line">行级锁：</span><br><span class="line">		开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发 度也最高。 </span><br><span class="line">页面锁(gap 锁,间隙锁)：</span><br><span class="line">		开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度 界于表锁和行锁之间，并发度一般。</span><br></pre></td></tr></table></figure>
<h3 id="MySQL基本数据类型："><a href="#MySQL基本数据类型：" class="headerlink" title="MySQL基本数据类型："></a>MySQL基本数据类型：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#1</span>. 数字：</span><br><span class="line">    整型：tinyinit  int  bigint</span><br><span class="line">    小数：</span><br><span class="line">        float ：在位数比较短的情况下不精准</span><br><span class="line">        double ：在位数比较长的情况下不精准</span><br><span class="line">            0.000001230123123123</span><br><span class="line">            存成：0.000001230000</span><br><span class="line"></span><br><span class="line">        decimal：（如果用小数，则用推荐使用decimal）</span><br><span class="line">            精准</span><br><span class="line">            内部原理是以字符串形式去存</span><br><span class="line"></span><br><span class="line"><span class="params">#2</span>. 字符串：</span><br><span class="line">    char（10）：简单粗暴，浪费空间，存取速度快</span><br><span class="line">        root存成root000000</span><br><span class="line">    varchar：精准，节省空间，存取速度慢</span><br><span class="line"></span><br><span class="line">    sql优化：创建表时，定长的类型往前放，变长的往后放</span><br><span class="line">                    比如性别           比如地址或描述信息</span><br><span class="line"></span><br><span class="line">    &gt;255个字符，超了就把文件路径存放到数据库中。</span><br><span class="line">            比如图片，视频等找一个文件服务器，数据库中只存路径或url。</span><br><span class="line"></span><br><span class="line"><span class="params">#3</span>. 时间类型：</span><br><span class="line">    最常用：datetime</span><br><span class="line"></span><br><span class="line"><span class="params">#4</span>. 枚举类型与集合类型</span><br></pre></td></tr></table></figure>

<h2 id="九、最后给了个情景题"><a href="#九、最后给了个情景题" class="headerlink" title="九、最后给了个情景题"></a>九、最后给了个情景题</h2><p>​        有10万个用户同时登陆，如何设置黑名单，使性能最佳。</p>
<p>​        我自己的答案是使用Redis进行控制，0是白名单，1是黑名单。但是设计时，key值怎么设计？这点我没想出来怎么合适，而且怎么保证效率性能最高？目前自己还在百度中。。。。。。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>2020-07-24—面试经历</p><p><a href="https://peialan.github.io/2020/07/24/2020-07-24—面试经历/">https://peialan.github.io/2020/07/24/2020-07-24—面试经历/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://peialan.github.io"><p>EllisonPei</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-07-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-03-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/02/23/2022-02-23%E2%80%94%E9%A1%B9%E2%BD%AC%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/" target="_blank">2022-02-23—项⽬如何排查JVM问题</a><br></span><span>  2.<a class="is-size-6" href="/2022/03/02/2022-03-02-Spring%20FrameWork%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" target="_blank">2022-03-02—spring Frame Work 5.3.10源码编译</a><br></span><span>  3.<a class="is-size-6" href="/2022/03/18/2022-03-18-redis%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/" target="_blank">2022-03-18—Redis高并发场景问题解析</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/reward/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/reward/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/04/2020-08-04-Spring%E4%BA%8B%E5%8A%A1%E4%B8%AD@Transactional(rollbackFor)%E7%9A%84%E7%94%A8%E6%84%8F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">2020-08-04-Spring事务中@Transactional(rollbackFor)的用意</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/18/2020-07-18%E2%80%94MySQL%E7%9A%84%E8%87%AA%E5%A2%9EID%E7%94%A8%E5%AE%8C%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E?/"><span class="level-item">2020-07-18—MySQL的自增ID用完了，怎么办?</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div class="content" id="comment-container"></div><script>var valine = new Valine({
            el: '#comment-container' ,
            notify: false,
            verify: false,
            appId: 'iMJmYJpiQTmDIHuXctJxx4EF-gzGzoHsz',
            appKey: 'MDrcq4xdFWWsWdOjPQOYalu9',
            placeholder: '留下您的高见！',
            avatar: 'mp',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false,
            path:'/2020/07/24/2020-07-24—面试经历/',
            lang:'zh-CN',
            enableQQ:true,
            requiredFields:["nick","mail","link"]
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#2020-07-24-面试经历（全程1个多小时）"><span>2020-07-24 面试经历（全程1个多小时）</span></a></li><li><a class="is-flex is-mobile" href="#一、自我介绍"><span>一、自我介绍</span></a></li><li><a class="is-flex is-mobile" href="#二、项目介绍，项目细节（业务，activiti工作流）"><span>二、项目介绍，项目细节（业务，activiti工作流）</span></a></li><li><a class="is-flex is-mobile" href="#三、从项目里延伸"><span>三、从项目里延伸</span></a></li><li><a class="is-flex is-mobile" href="#四、Java基础"><span>四、Java基础</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1、集合"><span>1、集合</span></a></li><li><a class="is-flex is-mobile" href="#2、引用类型"><span>2、引用类型</span></a></li><li><a class="is-flex is-mobile" href="#3、说一说Hashset"><span>3、说一说Hashset</span></a></li><li><a class="is-flex is-mobile" href="#4、说一说HashMap-1-7和1-8-，扩容机制-put操作的过程-答的不好"><span>4、说一说HashMap(1.7和1.8)，扩容机制,put操作的过程(答的不好)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#五、ConcurrentHashMap"><span>五、ConcurrentHashMap</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-8-ConcurrentHashMap的结构？"><span>1.8 ConcurrentHashMap的结构？</span></a></li><li><a class="is-flex is-mobile" href="#针对-ConcurrentHashMap锁机制具体分析（JDK-1-7-VS-JDK-1-8）？"><span>针对 ConcurrentHashMap锁机制具体分析（JDK 1.7 VS JDK 1.8）？</span></a></li><li><a class="is-flex is-mobile" href="#然后接着问了-concurrentHashMap-中哪个地方用了Synchronized，哪个地方用了CAS？"><span>然后接着问了 concurrentHashMap 中哪个地方用了Synchronized，哪个地方用了CAS？</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#六、线程问题"><span>六、线程问题</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#线程池的基本类型："><span>线程池的基本类型：</span></a></li><li><a class="is-flex is-mobile" href="#线程池的参数："><span>线程池的参数：</span></a></li><li><a class="is-flex is-mobile" href="#线程池的工作原理："><span>线程池的工作原理：</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#七、JVM"><span>七、JVM</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#内存结构"><span>内存结构</span></a></li><li><a class="is-flex is-mobile" href="#判断对象存活"><span>判断对象存活</span></a></li><li><a class="is-flex is-mobile" href="#各种引用对GC的影响"><span>各种引用对GC的影响</span></a></li><li><a class="is-flex is-mobile" href="#垃圾回收算法"><span>垃圾回收算法</span></a></li><li><a class="is-flex is-mobile" href="#垃圾回收器"><span>垃圾回收器</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#八、接着问了MySQL"><span>八、接着问了MySQL</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#B-树："><span>B+ 树：</span></a></li><li><a class="is-flex is-mobile" href="#MySQL锁："><span>MySQL锁：</span></a></li><li><a class="is-flex is-mobile" href="#MySQL基本数据类型："><span>MySQL基本数据类型：</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#九、最后给了个情景题"><span>九、最后给了个情景题</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png" alt="北北の酱"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">北北の酱</p><p class="is-size-6 is-block">尚未执佩剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">56</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PeiAlan" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PeiAlan"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:ellisonpei@foxmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Next" href="https://blog.lovewinter.top/about/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.jianshu.com/u/89ec42d8a581" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span><span class="level-right"><span class="level-item tag">www.jianshu.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-18T12:07:56.000Z">2022-03-18</time></p><p class="title"><a href="/2022/03/18/2022-03-18-redis%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/">2022-03-18—Redis高并发场景问题解析</a></p><p class="categories"><a href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-02T11:33:56.000Z">2022-03-02</time></p><p class="title"><a href="/2022/03/02/2022-03-02-Spring%20FrameWork%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">2022-03-02—spring Frame Work 5.3.10源码编译</a></p><p class="categories"><a href="/categories/Spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-23T01:33:56.000Z">2022-02-23</time></p><p class="title"><a href="/2022/02/23/2022-02-23%E2%80%94%E9%A1%B9%E2%BD%AC%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/">2022-02-23—项⽬如何排查JVM问题</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-28T01:33:56.000Z">2021-09-28</time></p><p class="title"><a href="/2021/09/28/2021-09-28-MacOS%E7%BC%96%E8%AF%91openjdk9/">2021-09-28—MacOS编译openjdk9</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-23T02:33:56.000Z">2021-08-23</time></p><p class="title"><a href="/2021/08/23/2021-08-23-%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E6%96%B9%E6%A1%88/">2021-08-23—双机热备实现方案</a></p><p class="categories"><a href="/categories/%E9%AB%98%E5%8F%AF%E7%94%A8/">高可用</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/DevTools/"><span class="level-start"><span class="level-item">DevTools</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ELK/"><span class="level-start"><span class="level-item">ELK</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MQ/"><span class="level-start"><span class="level-item">MQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Maven/"><span class="level-start"><span class="level-item">Maven</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mysql/"><span class="level-start"><span class="level-item">Mysql</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Oracle/"><span class="level-start"><span class="level-item">Oracle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/tomcat/"><span class="tag">tomcat</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java8/"><span class="tag">Java8</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java8/"><span class="tag">java8</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jdk/"><span class="tag">jdk</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9/"><span class="tag">linux分区扩容</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springboot/"><span class="tag">springboot</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssl/"><span class="tag">ssl</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AOP/"><span class="tag">AOP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AQS/"><span class="tag">AQS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JUC/"><span class="tag">JUC</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MQ/"><span class="tag">MQ</span><span class="tag is-grey-lightest">1</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m4uyne2jj20m606cgm1.jpg" alt="⋆北北の酱⋆" height="28"></a><p class="size-small"><span>&copy; 2022 EllisonPei</span>  Powered by <a href="https://blog.lovewinter.top/" target="_blank">EllisonPei</a>  <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">辽ICP备16008116号</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2019/11/02 00:00:00')", 250,"");</script><br></span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2227373273" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('iMJmYJpiQTmDIHuXctJxx4EF-gzGzoHsz','MDrcq4xdFWWsWdOjPQOYalu9','北北の酱','undefined',true);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('iMJmYJpiQTmDIHuXctJxx4EF-gzGzoHsz','MDrcq4xdFWWsWdOjPQOYalu9','北北の酱','undefined',true);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>